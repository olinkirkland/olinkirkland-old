<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Olin Kirkland</title>
    <link href="https://olinkirk.land/feed.xml" rel="self" />
    <link href="https://olinkirk.land" />
    <updated>2021-07-07T10:18:34+02:00</updated>
    <author>
        <name>Olin Kirkland</name>
    </author>
    <id>https://olinkirk.land</id>

    <entry>
        <title>Tectonic Plates</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/tectonic-plates/"/>
        <id>https://olinkirk.land/tectonic-plates/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-07-06T15:03:22+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/18/rundll32_2021-07-06_14-48-33.jpg" alt="" />
                    As discussed in my post about worldbuilding keystones, tectonic plates are a core concept that's really important to get right&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/18/rundll32_2021-07-06_14-48-33.jpg" alt="" />
                <p>As discussed in my post about <a href="https://olinkirk.land/defining-keystone-decisions/">worldbuilding keystones</a>, tectonic plates are a core concept that's really important to get right if things like mountain ranges, island chains, and realistic(ish) landmass formations. And if the resulting height map isn't at least kind of believable and follows some semblance of natural processes, nothing else will be.</p>
<p>My approach so far is a little simplistic, but I got to work out some kinks of how the different parts of the app interact with each other during the development, and due to the modular nature of how the app is structured, coming back to this step later on will be very straightforward.</p>
<blockquote>
<p><em>Tectonic plates</em> are pieces of Earth's crust and uppermost mantle.</p>
</blockquote>
<p>The theory of plate tectonics describes how these bits of crust have drifted around on the planet for the past three billion years, forming mountains when they crash into each other or trenches when they pull apart. Tectonic plates come in a variety of shapes and sizes, with each plate representing pretty distinct regions of the planet's surface.</p>
<figure class="post__image" ><img loading="lazy" src="https://upload.wikimedia.org/wikipedia/commons/thumb/8/8a/Plates_tect2_en.svg/1200px-Plates_tect2_en.svg.png" data-is-external-image="true"  alt="" width="717" height="490">
<figcaption >Earth's tectonic plates (Wikipedia)</figcaption>
</figure>
<p>If I wanted to really simulate plate tectonics, I'd have to model the different plates, their velocities, direction, the currents of magma beneath the crust, and how the plates change shape when they collide or sink. I don't really care too much (right now) about recreating the science behind plate tectonics, though it would be interesting to model plate movement and flora/fauna evolution over time. But for the purposes of my app, I don't think it's a crucial component. And like I said earlier, I can always come back to this step and do all that stuff.</p>
<p>I decided to simplify the process into some steps:</p>
<ol>
<li>Identify tectonic plate "origins" to flood-fill from</li>
<li>Expand the plates from their origins, taking into account a user-defined "jitter" to add randomness</li>
<li>Define a type for each plate (oceanic or continental)</li>
<li>Define a direction (random) for each plate</li>
</ol>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/18/adl_2021-07-06_14-46-33.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_14-46-33-xs.png 300w ,https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_14-46-33-sm.png 480w ,https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_14-46-33-md.png 768w"  alt="" width="1896" height="1021">
<figcaption >Assigning the tectonic plates in the app</figcaption>
</figure>
<p>I've decided not to worry about wrapping my map east-west, mainly because dealing with the voronoi points wrapping/repeating is a huge hassle and I've dealt with that before. Instead, I'm just assigning any tectonic plate that touches the border of the map to be a "deep" plate. This plate type is unique to the app (and not found in real life); the height map will ignore any border between deep plates. The idea is to get a big, flat ocean around a series of continents in the middle of the map. This way I can wrap around later when it comes to pathfinding, wind, climate, etc.</p>
<p>Assigning plate types is straightforward: I want some percent of the area to belong to continental plates, so I first sort the plates from smallest to largest, then assign their type to continental one by one until the total area of continental plates exceeds the goal. I haven't decided what that percent should be yet, but I'll play around with it until I'm happy with it.</p>
<p>It's totally possible for users to create their plates from scratch (well, to place the plate origins and choose the directions/types).</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/18/adl_2021-07-06_15-01-50.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_15-01-50-xs.png 300w ,https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_15-01-50-sm.png 480w ,https://olinkirk.land/media/posts/18/responsive/adl_2021-07-06_15-01-50-md.png 768w"  alt="" width="366" height="336">
<figcaption >Editing a tectonic plate in the toolbar's plate list</figcaption>
</figure>
<p>I added a "Quick Start" feature that gets prompted from a popup when entering the step to automatically generate plates from the get-go. I assume most users will just automatically generate plate combinations until they're happy with the result.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Drawing &amp; Layers</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/drawing-and-layers/"/>
        <id>https://olinkirk.land/drawing-and-layers/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-07-06T15:03:33+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/17/chrome_2021-06-18_10-16-50.jpg" alt="" />
                    Reimplementing the Layers Pane was easier than I expected. I had a lot of work done from before and was&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/17/chrome_2021-06-18_10-16-50.jpg" alt="" />
                <p>Reimplementing the Layers Pane was easier than I expected. I had a lot of work done from before and was able to copy most of the code directly from the <a href="https://olinkirk.land/worldmaker/">previous iteration</a>.</p>
<p>The major difference for layers this time comes down to code structure. Instead of sending events to the Map class, this time the Layers Pane and the Map pane both directly access the layers ArrayCollection that's created and stored in the TaskManager's currentTask. Since it's a singleton, there's no difficulty keeping the Map and Layers Pane in sync.</p>
<p>The TaskManager itself keeps tabs on the ArrayCollection and dispatches events through the Signal singleton letting any listener to the Signal class know if a change to the Layers has occurred.</p>
<p>Each task only initially stores the unique IDs of the layers that are to be displayed for that task. The actual Layer objects are initialized when the <code>resetLayers()</code> function is called (at the end of each Task class constructor). This function is also called when the layers are reset (returned to their original visibility and arrangement).</p>
<pre>public function resetLayers():void<br>{<br>    layers.removeAll();<br>    for each (var l:String in _layerIds)<br>    {<br>        var layer:Layer = new Layer();<br>        layer.id = l;<br>        layer.visible = true;<br>        layer.allowed = true;<br>        layers.addItem(layer);<br>    }<br>}</pre>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/17/adl_2021-06-18_10-25-29.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/17/responsive/adl_2021-06-18_10-25-29-xs.png 300w ,https://olinkirk.land/media/posts/17/responsive/adl_2021-06-18_10-25-29-sm.png 480w ,https://olinkirk.land/media/posts/17/responsive/adl_2021-06-18_10-25-29-md.png 768w"  alt="" width="469" height="205">
<figcaption >Finally, a functional layers pane for the new build</figcaption>
</figure>
<p>Drawing the map itself takes on a different approach as well. The <code>onDraw(event)</code> function contains a switch by layer id, and loops over each layer in the currentTask's Layers ArrayCollection. I decided to separate the act of drawing each layer into individual functions dedicated to that particular layer's visualization.</p>
<pre>for each (var layer:Layer in layers)<br>{<br>    if (!layer.visible)<br>        continue;<br><br>    switch (layer.id)<br>    {<br>        case Layer.POINTS:<br>            drawPoints();<br>            break;<br>        case Layer.VORONOI:<br>            drawVoronoi();<br>            break;<br>        case Layer.DELAUNAY:<br>            drawDelaunay();<br>            break;<br>        case Layer.TECTONIC_PLATES:<br>            drawTectonics();<br>            break;<br>    }<br>}</pre>
<p>If a new layer is to be added to some task, the easy scalability of this approach makes it very straightforward to expand tasks without needing to delve deep into existing code.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Code Structure &amp; State Management</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/code-structure-and-state-management/"/>
        <id>https://olinkirk.land/code-structure-and-state-management/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-06-16T16:28:09+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/16/urban-construction-building-sketch-city-house-town-vector-illustration-isolated-white-background-85788471.jpg" alt="" />
                    Since the structure of the application and the user's actions revolves around tasks (keystone decisions), it feels right to build&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/16/urban-construction-building-sketch-city-house-town-vector-illustration-isolated-white-background-85788471.jpg" alt="" />
                <p>Since the structure of the application and the user's actions revolves around tasks (keystone decisions), it feels right to build the structure of the code around these as well. To do this, I decided to make a Task class that contains all the information for a task, including the task's name and references to relevant modules.</p>
<p>A singleton contains all tasks and can perform operations like setting the current task or incrementing to the next task.</p>
<p>Tasks need to have a lot of control over the application state, and be referenced to see what gets displayed and calculated. Essentially a task acts the way a game cartridge would in a gaming console - you slide on in and you could have a totally different game, but it is still controlled using the same way (a controller) and still communicates information to the user using the same methods (a screen/sound).</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/16/Task-1.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/16/responsive/Task-1-xs.png 300w ,https://olinkirk.land/media/posts/16/responsive/Task-1-sm.png 480w ,https://olinkirk.land/media/posts/16/responsive/Task-1-md.png 768w"  alt="" width="964" height="512">
<figcaption >Different events act upon the task</figcaption>
</figure>
<p>Different events (in the game console metaphor, controllers) will act on the task. It's important for each task therefore to have a function to handle any of these events. Creating an abstract Task class to inherit the other task classes from helps keep this organized.</p>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Defining Keystone Decisions</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/defining-keystone-decisions/"/>
        <id>https://olinkirk.land/defining-keystone-decisions/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-07-07T10:18:34+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/15/L-Karniesbogen_keystone.png" alt="" />
                    My Worldmaker app centers around keystone decisions defined by the user. Each decision is a step toward generating a cool&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/15/L-Karniesbogen_keystone.png" alt="" />
                <p>My Worldmaker app centers around keystone decisions defined by the user. Each decision is a step toward generating a cool fantasy world that the user can use for game development or Dungeons &amp; Dragons-style worldbuilding. In code, each keystone decision has its own class that handles all calculations and updates the state directly. This is the first draft.</p>
<ol>
<li><strong>Points: </strong>Determine the map points and generate the voronoi graph. The world has to be generated on a base that can be referenced and manipulated by the code. This will provide cells - the basic building blocks of the map.</li>
<li><strong>Tectonics:</strong> Make the tectonic plates. Plates are generated by a simple flood-fill algorithm. Tectonic plates have several properties that the user may define: Origin cell, strength, random-ness, color, bend type (convex or concave), bend strength, elevation, and direction.</li>
<li><strong>Terrain: </strong>Terrain is generated using <a href="https://www.nationalgeographic.com/science/article/plate-tectonics" target="_blank" rel="noopener noreferrer">tectonic plate boundary rules</a>. Sea level, terrain randomness and coastal erosion are also set here.</li>
<li><strong>Islands: </strong>Because islands are kind of ignored by my tectonics and terrain generation algorithms, I think it's appropriate to add them in their own step. Island clusters can be a unique tectonic cell type and are <a href="https://www.worldatlas.com/articles/how-many-types-of-islands-are-there.html" target="_blank" rel="noopener noreferrer">generated for special cases</a>.</li>
<li><strong>Temperature: </strong>Poles are cold, equator is warm. Let users define the temperature gradient and equator.</li>
<li><strong>Wind: </strong>This one's going to be difficult, but essentially determine which direction wind flows, globally. Atmospheric pressure simulation? <a href="https://media.springernature.com/lw785/springer-static/image/prt%3A978-0-387-30749-7%2F19/MediaObjects/978-0-387-30749-7_19_Part_Fig21_HTML.jpg" target="_blank" rel="noopener noreferrer">Hmm.</a></li>
<li><strong>Moisture:</strong> Wind and temperature defines how much water wind picks up from the ocean and dumped on land.</li>
<li><strong>Rivers</strong>: Use moisture values to determine where rivers flow to the sea.</li>
<li><strong>Biomes: </strong>Use rainfall and temperature to determine biomes.</li>
<li><strong>Flora &amp; Fauna: </strong>Generate flora and fauna from a list of plants and animals. Users can define what flora &amp; fauna are allowed/disallowed from the source list.</li>
<li><strong>Regions: </strong>Generate initial nodes where towns can spawn, and the regions around them. Each node defines the desirability and resources of the possible town. Think of regions as simply the area around a town.</li>
<li><strong>Tribes: </strong>Generate tribes of people with unique languages and spawn them in different parts of the world. Flood fill them, and they will build towns on owned nodes and name regions they are familiar with.</li>
<li><strong>Timeline Simulation</strong>: The end-point of the generator. Start the timeline sequence. Timeline sequence to be described in another post.</li>
</ol>
            ]]>
        </content>
    </entry>
    <entry>
        <title>(re)Planning Worldmaker</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/replanning-worldmaker/"/>
        <id>https://olinkirk.land/replanning-worldmaker/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-06-16T16:28:25+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/14/adl_2021-05-14_11-14-33.png" alt="" />
                    A decent amount of work has gone into Worldmaker, and I kind of knew at the back of my head&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/14/adl_2021-05-14_11-14-33.png" alt="" />
                <p>A decent amount of work has gone into Worldmaker, and I kind of knew at the back of my head that there would need to be a rework but I didn't expect to do it this soon.</p>
<p>The core concept behind Worldmaker is putting the user behind the wheel of <strong>keystone decisions</strong>, called "Tasks" in the app. I realize now that I should have planned out a larger number of these before jumping into the code.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/14/chrome_2021-05-14_14-15-56.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/14/responsive/chrome_2021-05-14_14-15-56-xs.png 300w ,https://olinkirk.land/media/posts/14/responsive/chrome_2021-05-14_14-15-56-sm.png 480w ,https://olinkirk.land/media/posts/14/responsive/chrome_2021-05-14_14-15-56-md.png 768w"  alt="" width="461" height="430">
<figcaption >All tasks can be viewed in one handy popup</figcaption>
</figure>
<p>As development progressed, I realized that it's really important that these tasks and their associated code:</p>
<ol>
<li>Are <strong>modular</strong></li>
<li>Can easily have new ones added or inserted</li>
<li>Have easy <strong>access </strong>to the state</li>
</ol>
<p>Unfortunately as I worked, I realized I had dug myself a pretty convoluted hole of a structure where a lot of the logic was performed within the "toolbar" - a UI element appearing on the right side of the screen, and due to the state's decidedly untyped nature, things got hard to understand fast, especially if I hadn't worked on it in a few days.</p>
<p>The first task is more of a test case than anything. It requires the user to read a short introduction text in the toolbar, then continue to the next task.</p>
<figure class="post__image post__image--center" ><img loading="lazy" src="https://olinkirk.land/media/posts/14/adl_2021-05-14_10-24-26.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/14/responsive/adl_2021-05-14_10-24-26-xs.png 300w ,https://olinkirk.land/media/posts/14/responsive/adl_2021-05-14_10-24-26-sm.png 480w ,https://olinkirk.land/media/posts/14/responsive/adl_2021-05-14_10-24-26-md.png 768w"  alt="" width="1896" height="1021">
<figcaption >The first task</figcaption>
</figure>
<ul>
<li><strong>Top Bar: </strong>Along the top of the screen, there's a pretty empty bar whose only real purpose is to hold the logo and the save button. In the future, app-level buttons will go here - to access options or screenshot functionality.</li>
<li><strong>Layers:</strong> On the far left, there's a layers panel that is hidden by default. Map layers can be toggled and rearranged from this panel. Layers that are not available are locked.</li>
<li><strong>The Map:</strong> In the center of the screen is the map. The map is directly changed by the state. When there's a state change event, the map redraws the affected layers.</li>
<li><strong>The Toolbar:</strong> The toolbar is where the user can affect the current task or progress to the next task. Changing options in the toolbar affects the state.</li>
</ul>
<p>User flow goes something like this:</p>
<ol>
<li>User makes a change to toolbar</li>
<li>State changes</li>
<li>Map changes to reflect state change</li>
</ol>
<p>My big mistake was not to abstract the state, and fail to create an overall modularization of the different tasks as their own classes. Since a lot of logic takes place within the toolbar itself right now, I need to figure out how to organize the code and content so that the toolbar does no logic and only forwards the desired changes to a state controller that knows what the current task is and what classes will take over the necessary calculations.</p>
<p>My next step will be to create a proper flow chart that can be referred to when crafting a new structure for the program.</p>
<div class="gallery-wrapper"><div class="gallery"  data-is-empty="false" data-columns="3">
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-05-26.png" data-size="1896x1021"><img loading="lazy" src="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-05-26-thumbnail.png" alt="" width="768" height="414"></a>
<figcaption>Poisson Points</figcaption>
</figure>
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-06-08.png" data-size="1896x1021"><img loading="lazy" src="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-06-08-thumbnail.png" alt="" width="768" height="414"></a>
<figcaption>Hexagon Points</figcaption>
</figure>
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-05-59.png" data-size="1896x1021"><img loading="lazy" src="https://olinkirk.land/media/posts/14/gallery/adl_2021-05-14_11-05-59-thumbnail.png" alt="" width="768" height="414"></a>
<figcaption>Square Points</figcaption>
</figure>
</div></div>
            ]]>
        </content>
    </entry>
    <entry>
        <title>Worldmaker</title>
        <author>
            <name>Olin Kirkland</name>
        </author>
        <link href="https://olinkirk.land/worldmaker/"/>
        <id>https://olinkirk.land/worldmaker/</id>
            <category term="Worldmaker"/>
            <category term="Blog"/>

        <updated>2021-06-16T16:28:32+02:00</updated>
            <summary>
                <![CDATA[
                        <img src="https://olinkirk.land/media/posts/13/adl_2021-03-11_23-15-00.png" alt="" />
                    My world generation projects have gone through a few iterations now. First, I had "Realms", in which I did a&hellip;
                ]]>
            </summary>
        <content type="html">
            <![CDATA[
                    <img src="https://olinkirk.land/media/posts/13/adl_2021-03-11_23-15-00.png" alt="" />
                <p>My world generation projects have gone through a few iterations now.</p>
<p>First, I had "Realms", in which I did a ton of cool stuff like drawing forests and rivers, generating height maps from different effects (like island shapes and preset mountain ranges), creating regions with natural boundaries like rivers, mountains, and coasts, determining the best place for cities and towns to be located, and an extensive naming system that used word combinations in English and German to produce believable medieval place names. This was really exciting to put together but the technical debt became too great in the end and I was having a lot of trouble with wind simulation, continent generation, my code structure, and miserable performance. I put down the procedural experimenting for a while.</p>
<figure class="post__image" ><img loading="lazy" src="https://olinkirk.land/media/posts/13/chrome_2021-03-11_23-21-56.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/13/responsive/chrome_2021-03-11_23-21-56-xs.png 300w ,https://olinkirk.land/media/posts/13/responsive/chrome_2021-03-11_23-21-56-sm.png 480w ,https://olinkirk.land/media/posts/13/responsive/chrome_2021-03-11_23-21-56-md.png 768w"  alt="Realms with forests, cities, and connecting roads" width="2260" height="1461">
<figcaption >Realms with forests, cities, and connecting roads</figcaption>
</figure>
<p>Then, I decided that realms weren't enough. I wanted to make "Worlds". Realms had never felt that big, really - the regions felt kind of small and the islands produced by the generator didn't look or act like real continents. I also had had a lot of trouble with rendering mountains and wanted to do something more '3D'. So I started with Worlds. It felt really good going back to the drawing board and beginning with an eye on performance: I used a quad-tree to keep track of the voronoi cell points so that finding points would be smooth. The different logic layers like wind and hydrology were separated reasonably into different areas of the code instead of being jumbled together. The logic occurred in one place and once it was done, the map was drawn in a single step. In general, Worlds was leaps and bounds ahead of Realms.</p>
<figure class="post__image" ><img loading="lazy" src="https://olinkirk.land/media/posts/13/adl_2021-03-09_23-23-45.png" sizes="(max-width: 48em) 100vw, 100vw" srcset="https://olinkirk.land/media/posts/13/responsive/adl_2021-03-09_23-23-45-xs.png 300w ,https://olinkirk.land/media/posts/13/responsive/adl_2021-03-09_23-23-45-sm.png 480w ,https://olinkirk.land/media/posts/13/responsive/adl_2021-03-09_23-23-45-md.png 768w"  alt="Worlds with &quot;low-poly&quot; style relief shading" width="1692" height="968">
<figcaption >Worlds with "low-poly" style relief shading</figcaption>
</figure>
<p>But even so, some of the new features I added felt cumbersome. Settings were organized pretty poorly and wind still didn't work well. I thought the 3D style initially looked really good but the longer I worked with it the more tiresome it grew. I really wanted to make a stylized 2D map and the low-poly shading just wasn't doing that for me. The tectonics system I introduced was good on the surface but only about 10% of the resulting maps looked "fun".</p>
<p>Here comes Worldmaker.</p>
<ol>
<li>No longer satisfied with purely procedural maps, I want to make an application that <strong>lets the user define different "keystone" decisions</strong> that are hard to generate.</li>
<li>I want to release the app once it's functional to get feedback - and continue to <strong>release versions with improvements</strong> that enhance or replace the "keystone" decisions.</li>
<li>To do this, I decided to <strong>make a launcher</strong> first. A launcher will let users install different versions of the app and create, load, and share their own world projects.</li>
</ol>
<p>What are examples of "keystone" decisions? In Realms, only one keystone could be set: The map's seed, a number used to determine every random aspect of the map. Worlds introduced a number of settings to fine tune the map, but the map settings weren't stored with the map. Sea level, wind strength, and average temperature are all easily set keystones with a slider but something like tectonic plate design or island chains is not.</p>
<p>I want this to be a lot closer to what Azgaar does in his map generator, but more step-by-step and intuitive as far as UI goes.</p>
<div class="gallery-wrapper"><div class="gallery"  data-is-empty="false" data-columns="3">
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/13/gallery/adl_2021-03-11_23-05-25.png" data-size="480x671"><img loading="lazy" src="https://olinkirk.land/media/posts/13/gallery/adl_2021-03-11_23-05-25-thumbnail.png" alt="" width="480" height="671"></a>
<figcaption>Creating a new project</figcaption>
</figure>
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/13/gallery/adl_2021-03-11_23-09-54.png" data-size="1920x1080"><img loading="lazy" src="https://olinkirk.land/media/posts/13/gallery/adl_2021-03-11_23-09-54-thumbnail.png" alt="" width="768" height="432"></a>
<figcaption>Managing versions</figcaption>
</figure>
<figure class="gallery__item"><a href="https://olinkirk.land/media/posts/13/gallery/chrome_2021-03-01_13-21-16.png" data-size="984x734"><img loading="lazy" src="https://olinkirk.land/media/posts/13/gallery/chrome_2021-03-01_13-21-16-thumbnail.png" alt="https://dribbble.com/shots/10090105-Dashboard-UI" width="768" height="573"></a>
<figcaption>UI Design Inspiration</figcaption>
</figure>
</div></div>
<p>I've spent several evenings designing and writing the code for the different UI components in the launcher, and the style will carry over into the application itself.</p>
            ]]>
        </content>
    </entry>
</feed>
